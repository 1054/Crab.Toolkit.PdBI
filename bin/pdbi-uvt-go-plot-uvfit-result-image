#!/bin/bash
# 
# plot image using supermongo


if [[ $(type sm 2>/dev/null | wc -l) -eq 0 ]]; then
    echo "Error! Supermongo was not found in \$PATH!"
    exit
else
    if [[ $(echo "load crabPlot.sm" | sm | wc -l) -ne 0 ]]; then
        echo "Error! We need Supermongo macro \"crabPlot.sm\" from \"https://github.com/1054/DeepFields.SuperDeblending/Softwares/Supermongo_macro/crabPlot.sm\"!"
        exit
    fi
fi

if [[ $# -lt 1 ]]; then
    echo "Usage: pdbi-uvt-go-plot-uvfit-result-image *.uvt -radec ra dec -offset xoff yoff [-output output_name]"
    exit
fi

function Is_Float_Number() {
    # http://stackoverflow.com/questions/13790763/bash-regex-to-check-floating-point-numbers-from-user-input
    #echo $1
    if [[ $# -ge 1 ]]; then
        #regExp='^[+-]?([0-9]+\.?|[0-9]*\.[0-9]+)$'
        regExp='^([+-])?([0-9]+\.?|[0-9]*\.[0-9]+)([eE][+-]?[0-9]+)?$'
        if [[ "$1" =~ $regExp ]]; then
            #echo "That is a number!"
            return 0
        else
            #echo "Damn! Not A Number!"
            #seq  -f "*" -s '' $(echo "${#1}+7+2+23" | bc); echo
            #echo "Error! \"$1\" is not a float number!"
            #seq  -f "*" -s '' $(echo "${#1}+7+2+23" | bc); echo
            #exit -1
            return 200
        fi
    fi
    return 200
}

uv_filename=$(echo $1 | sed -e 's/\.uvt$//g')

echo "! GILDAS MAPPING SCRIPT" > "pdbi_uvt_go_plot_uvfit_result_image.map"
echo "let name \"$uv_filename\"" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
echo "let map_size 1024" >> "pdbi_uvt_go_plot_uvfit_result_image.map" #<Added><20170909># 
echo "go uvmap" >> "pdbi_uvt_go_plot_uvfit_result_image.map" #<Added><20170816># 
echo "fits 'name'.lmv-dirty.fits from 'name'.lmv /overwrite" >> "pdbi_uvt_go_plot_uvfit_result_image.map" #<Added><20170909># 
echo "let type lmv" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
echo "read uv 'name'.uvt" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
#echo "INPUT UV_MAP" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
#echo "UV_MAP" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
#echo "UV_STAT WEIGHT" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
#echo "UV_MAP" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
#echo "go uvmap" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
echo "read dirty 'name'.lmv" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
echo "read beam 'name'.beam" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
echo "go bit" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
# 
#echo "let size 30" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
# 
if [[ $* == *"-size "* ]]; then
    msize=($(echo $* | perl -p -e 's/.* -size[ ]+([0-9.+-]+).*/\1/g'))
    if [[ $(awk "BEGIN {if ($msize>0) print 1; else print 0;}") -eq 1 ]]; then
        echo "let size $msize" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
    fi
fi
if [[ $* == *"-fov "* ]]; then
    msize=($(echo $* | perl -p -e 's/.* -fov[ ]+([0-9.+-]+).*/\1/g'))
    if [[ $(awk "BEGIN {if ($msize>0) print 1; else print 0;}") -eq 1 ]]; then
        echo "let size $msize" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
    fi
fi
if [[ $* == *"-FoV "* ]]; then
    msize=($(echo $* | perl -p -e 's/.* -FoV[ ]+([0-9.+-]+).*/\1/g'))
    if [[ $(awk "BEGIN {if ($msize>0) print 1; else print 0;}") -eq 1 ]]; then
        echo "let size $msize" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
    fi
fi
# 
echo "let niter 1" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
echo "clean" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
# 
#echo "write * 'name'" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
echo "write clean 'name'.lmv-clean" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
echo "fits 'name'.lmv-clean.fits from 'name'.lmv-clean /overwrite" >> "pdbi_uvt_go_plot_uvfit_result_image.map" #<Added><20170909># 
echo "let type lmv-clean" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
echo "go noise" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
echo "let spacing noise" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
#echo "lut rainbow3" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
echo "let do_bit yes" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
echo "let do_contour yes" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
# 
if [[ $* == *"-noheader"* ]]; then
echo "let do_header no" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
fi
# 
echo "go nice" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
# 
echo "define header UVT_HEADER 'name'.uvt read" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
echo "define real OBJ_RA_OFF" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
echo "define real OBJ_DEC_OFF" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
echo "define real OBJ_BOX_SIZE" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
# 
if [[ $* == *"-radec "* ]]; then
    #radec=($(echo $* | perl -p -e 's/.* -radec[ ]+([0-9.+-:]+)[ ]+([0-9.+-:]+).*/\1 \2/g')) # must be in degrees
    radec_arg=0
    radec=()
    for (( i=1; i<=$#; i++ )); do
        if [[ "${!i}" == "-radec" ]]; then radec_arg=1; continue; fi
        if [[ $radec_arg -eq 1 ]]; then
            radec_str=$(echo "${!i}" | sed -e 's/://g')
            if Is_Float_Number "$radec_str"; then
                radec+=("${!i}")
            else
                radec_arg=0
            fi
        fi
    done
    echo "Setting radec ${radec[@]}"
    while [[ ${#radec[@]} -ge 2 ]]; do
        if [[ ${radec[0]} == *":"* || ${radec[1]} == *":"* ]]; then
            radec_sexagement=(${radec[@]})
            radec_degree=($(radec2degree ${radec_sexagement[0]} ${radec_sexagement[1]}))
            ra_radian=$(awk "BEGIN {printf \"%0.15f\", (${radec_degree[0]})/180.0*3.14159265358979}")
            dec_radian=$(awk "BEGIN {printf \"%0.15f\", (${radec_degree[1]})/180.0*3.14159265358979}")
        else
            ra_radian=$(awk "BEGIN {printf \"%0.15f\", (${radec[0]})/180.0*3.14159265358979}")
            dec_radian=$(awk "BEGIN {printf \"%0.15f\", (${radec[1]})/180.0*3.14159265358979}")
        fi
        radec=(${radec[@]:2})
        echo "ra_radian = $ra_radian"
        echo "dec_radian = $dec_radian"
        echo "" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "LET OBJ_DEC_OFF = '($dec_radian - UVT_HEADER%D0)'" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "LET OBJ_RA_OFF = '($ra_radian - UVT_HEADER%A0) * COS(UVT_HEADER%D0)'" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "LET OBJ_BOX_SIZE = '2.0 / 3600.0 / 180.0 * 3.14159265358979'" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "EXAM OBJ_RA_OFF" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "EXAM OBJ_DEC_OFF" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "EXAM OBJ_BOX_SIZE" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "PENCIL /COLOUR BLACK /WEIGHT 5" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "DRAW RELOCATE 'OBJ_RA_OFF-OBJ_BOX_SIZE/2' 'OBJ_DEC_OFF-OBJ_BOX_SIZE/2' /USER" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "DRAW LINE     'OBJ_RA_OFF-OBJ_BOX_SIZE/2' 'OBJ_DEC_OFF+OBJ_BOX_SIZE/2' /USER" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "DRAW LINE     'OBJ_RA_OFF+OBJ_BOX_SIZE/2' 'OBJ_DEC_OFF+OBJ_BOX_SIZE/2' /USER" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "DRAW LINE     'OBJ_RA_OFF+OBJ_BOX_SIZE/2' 'OBJ_DEC_OFF-OBJ_BOX_SIZE/2' /USER" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "DRAW LINE     'OBJ_RA_OFF-OBJ_BOX_SIZE/2' 'OBJ_DEC_OFF-OBJ_BOX_SIZE/2' /USER" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "PENCIL 0" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
    done
fi
# 
if [[ $* == *"-offset "* ]]; then
    #offset=($(echo $* | perl -p -e 's/.* -offset[ ]+([0-9.+-:]+)[ ]+([0-9.+-:]+).*/\1 \2/g')) # must be in degrees
    offset_arg=0
    offset=()
    for (( i=1; i<=$#; i++ )); do
        if [[ "${!i}" == "-offset" ]]; then offset_arg=1; continue; fi
        if [[ $offset_arg -eq 1 ]]; then
            offset_str=$(echo "${!i}" | sed -e 's/://g')
            if Is_Float_Number "$offset_str"; then
                offset+=("${!i}")
            else
                offset_arg=0
            fi
        fi
    done
    echo "Setting offset ${offset[@]}"
    while [[ ${#offset[@]} -ge 2 ]]; do
        ra_offset=${offset[0]}
        dec_offset=${offset[1]}
        offset=(${offset[@]:2})
        echo "ra_offset = $ra_offset"
        echo "dec_offset = $dec_offset"
        echo "" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "LET OBJ_DEC_OFF = '($dec_offset) / 3600.0 / 180.0 * 3.14159265358979'" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "LET OBJ_RA_OFF = '($ra_offset) / 3600.0 / 180.0 * 3.14159265358979'" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "LET OBJ_BOX_SIZE = '2.0 / 3600.0 / 180.0 * 3.14159265358979'" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "EXAM OBJ_RA_OFF" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "EXAM OBJ_DEC_OFF" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "EXAM OBJ_BOX_SIZE" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "PENCIL /COLOUR BLACK /WEIGHT 5" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "DRAW RELOCATE 'OBJ_RA_OFF-OBJ_BOX_SIZE/2' 'OBJ_DEC_OFF-OBJ_BOX_SIZE/2' /USER" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "DRAW LINE     'OBJ_RA_OFF-OBJ_BOX_SIZE/2' 'OBJ_DEC_OFF+OBJ_BOX_SIZE/2' /USER" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "DRAW LINE     'OBJ_RA_OFF+OBJ_BOX_SIZE/2' 'OBJ_DEC_OFF+OBJ_BOX_SIZE/2' /USER" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "DRAW LINE     'OBJ_RA_OFF+OBJ_BOX_SIZE/2' 'OBJ_DEC_OFF-OBJ_BOX_SIZE/2' /USER" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "DRAW LINE     'OBJ_RA_OFF-OBJ_BOX_SIZE/2' 'OBJ_DEC_OFF-OBJ_BOX_SIZE/2' /USER" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
        echo "PENCIL 0" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
    done
fi
# 
#echo "LET DO_HEADER NO" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
#echo "LET DO_NICE YES" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
# 
echo "" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
echo "hardcopy pdbi_uvt_go_plot_uvfit_result_image.eps /OVERWRITE" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
echo "" >> "pdbi_uvt_go_plot_uvfit_result_image.map"
# 
echo "@pdbi_uvt_go_plot_uvfit_result_image.map | mapping -nw -nl"
echo "@pdbi_uvt_go_plot_uvfit_result_image.map" | mapping -nw -nl
# 
if [[ -f "pdbi_uvt_go_plot_uvfit_result_image.eps" ]]; then
    ps2pdf -dEPSCrop "pdbi_uvt_go_plot_uvfit_result_image.eps" "pdbi_uvt_go_plot_uvfit_result_image.pdf"
fi
# 
# Final output
if [[ $* == *"-output "* ]]; then
    output=($(echo $* | perl -p -e 's/.* -output[ ]+([^ ]+).*/\1/g')) # must be in degrees
    for i in map pdf; do
        mv "pdbi_uvt_go_plot_uvfit_result_image.${i}" "${output}.${i}"
        echo "Output to \"${output}.${i}\""
    done
fi



